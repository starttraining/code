pip install langgraph

Step 1: Defining the state and node functions

from typing import TypedDict
from langgraph.graph import StateGraph, END

# Define the structure of our state
class GraphState(TypedDict):
  """
  Represents the state of our graph.
  Attributes:
    message: The welcome message.
    question: The follow-up question.
  """
  message: str
  question: str

# Define the node functions
def welcome(state: GraphState) -> dict:
"""Adds a welcome message to the state."""
  state["message"] = "Welcome to LangGraph!"
  return state

def question(state: GraphState) -> dict:
"""Adds a follow-up message to the state."""
  state["question"] = "How can I help you today?"
  return state

def display(state: GraphState) -> dict:
"""Retrieves messages and prints them to the console."""
  print(state["message"])
  print(state["question"])
  return {}  # This node doesn't modify the state

Here’s what each part does:

GraphState defines that our state dictionary will contain string keys named message and question.
welcome(state) adds a welcome message to the state.
question(state) adds a follow-up message to the state.
display(state) retrieves both and prints them to the console.
Step 2: Initializing the graph and adding nodes

# The graph needs to know what the state schema is
graph = StateGraph(GraphState)

# Add the three functions as named nodes
graph.add_node("welcome", welcome)
graph.add_node("question", question)
graph.add_node("display", display)

Step 3: Defining the execution order with edges

graph.set_entry_point("welcome")
graph.add_edge("welcome", "question")
graph.add_edge("question", "display")
graph.add_edge("display", END)

Step 4: Compile and run the workflow

# This creates the runnable app
app = graph.compile()

# Run the app with an empty initial state
app.invoke({})

***********************************************************************
How to manage complex workflows?

from typing import TypedDict
from langgraph.graph import StateGraph, END

# Define the state for this conditional graph
class ConditionalState(TypedDict):
  input: str # User's query
  next: str  # The next node to route to

# Define the functions
def check_query(state: ConditionalState) -> dict:
  """Checks the query and returns a routing decision."""
  query = state.get("input", "").lower()
    if "pricing" in query:
      return {"next": "pricing"}
    else:
      return {"next": "general"}

def pricing_info(state: ConditionalState) -> dict:
  """Provides pricing information."""
  print("Here’s detailed pricing information.")
  return {}

def general_info(state: ConditionalState) -> dict:
"""Provides general information."""
  print("Here’s some general information.")
  return {}

# Set up the graph
graph = StateGraph(ConditionalState)
graph.add_node("check", check_query)
graph.add_node("pricing", pricing_info)
graph.add_node("general", general_info)

# Set the entry point and the conditional edges
graph.set_entry_point("check")
graph.add_conditional_edges(
  "check", # The source node for the decision
  lambda state: state["next"], # A function to extract the routing key from the state
  {
    # A map of routing keys to destination nodes
    "pricing": "pricing",
    "general": "general"
  }
)

# Add edges from the final nodes to the end
graph.add_edge("pricing", END)
graph.add_edge("general", END)

# Compile and run
app = graph.compile()
app.invoke({"input": "I need to know about your pricing plans."})



